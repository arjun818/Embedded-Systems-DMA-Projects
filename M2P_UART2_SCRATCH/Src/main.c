/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"

void button_init(void);
void uart2_init(void);
void dma1_init(void);
void send_some_data(void);
void enable_dma1_stream(void);
void dma1_interrupt_configuration(void);

//Callbacks
void HT_Complete_Callback();
void FT_Complete_Callback();
void TE_Error_Callback();
void FE_Error_Callback();
void DME_Error_Callback();


#define BASE_ADDR_OF_GPIOA_PERI GPIOA

char dataStream[] = "Hi amma, achan and Udit all slept?\r\n";

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	button_init();
	uart2_init();
//	send_some_data();
	dma1_init();
	dma1_interrupt_configuration();
	enable_dma1_stream();
    /* Loop forever */
	for(;;);
}

void button_init(void){
	//Button is connected to PA0. GPIOA pin number 0
	GPIO_TypeDef *pGPIOA;
	pGPIOA = BASE_ADDR_OF_GPIOA_PERI;

	RCC_TypeDef *pRCC;
	pRCC= RCC;

	EXTI_TypeDef *pEXTI;
	pEXTI = EXTI;

	SYSCFG_TypeDef *pSYSCRG;
	pSYSCRG = SYSCFG;

	//1. Enable the peripheral clk for the GPIOA peripheral
	pRCC->AHB1ENR |= (1 << 0);

	//2. Keep the GPIO pin in I/P mode.
	pGPIOA->MODER &= ~(0x3 << 0);

	//3. Enable the interrupt over that GPIO pin.
	pEXTI->IMR = (1<<0);


	//4. Enable the clk for SYSCFG
	pRCC->APB2ENR |= (1 << 14);

	//5.  Configuring the SYSCFG CR1 register
	pSYSCRG->EXTICR[0] &= ~(0xF << 4);//Clearing
	pSYSCRG->EXTICR[0] |=  (0x0 << 4);//Setting

	//6. Configure the edge detection on the GPIO pin.
	pEXTI->FTSR = (1<<0);

	//7. Enable the IRQ related to that GPIO pin in NVIC-registere of the processor.
	NVIC_EnableIRQ(EXTI0_IRQn);
}
void uart2_init(void){
	RCC_TypeDef *pRCC;
	pRCC= RCC;

	GPIO_TypeDef *pGPIOA;
	pGPIOA = BASE_ADDR_OF_GPIOA_PERI;

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	//1. Enable the peripheral clk for UART2 peripheral.
	pRCC->APB1ENR |= (1<<17);

	//2. Configure the GPIO pins for UART_TX and UART_RX.
	//PA2=TX and PA3=RX

	//First lets configure PA2 as UART2 TX

	//2.1 Enable the clk for the GPIOA peripheral
	pRCC->AHB1ENR |=(1 << 0);

	//2.2 Change the mode to AF mode for the PA2.
	pGPIOA->MODER &= ~(0x3 <<4);
	pGPIOA->MODER |=  (0x2 << 4);

	pGPIOA->AFR[0] &= ~(0xF << 8);
	pGPIOA->AFR[0] |=  (0x7 << 8);
	//2.3 Enable pull up or pull down resistor if required.
	pGPIOA->PUPDR |= (0x1 << 4);

	//Second lets configure PA3 as UART2 RX


	//2.4 Change the mode to AF mode for the PA2.
	pGPIOA->MODER &= ~(0x3 <<6);
	pGPIOA->MODER |=  (0x2 << 6);

	pGPIOA->AFR[0] &= ~(0xF << 12);
	pGPIOA->AFR[0] |=  (0x7 << 12);
	//2.5 Enable pull up or pull down resistor if required.
	pGPIOA->PUPDR |= (0x1 << 6);

	//3. Configure the baudrate.
	pUART2->BRR = 0x8B;

	//4. Configure the data width, no of stop bits, etc.
	//<No configuration required we will use default values.>

	//5. Enable the Tx engine of UART peripheral.
	pUART2->CR1 |= (1 << 3);
	//6. Enable the UART peripheral.
	pUART2->CR1 |= (1 << 13);


}
void send_some_data(void){
	char data[] = "Hi amma kutty\r\n";

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	//1. Make sure that the SR TXE is set. If TXE is 1, put the byte.
	//We are waiting for TXE to become 1
	for(uint32_t i=0; data[i]!='\0'; i++){
	while(!(pUART2->SR & (1 << 7)));
	pUART2->DR = data[i];
	}

}
void dma1_init(void){

	RCC_TypeDef *pRCC;
	pRCC = RCC;

	DMA_Stream_TypeDef *pStream6;
	pStream6 = DMA1_Stream6;

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	//1. Enable the peripheral clk for DMA1.
	pRCC->AHB1ENR |=(1<<21);

	//2. Identify the stream which is suitable for your peripheral.
	//Channel 4, stream 6

	//3. Identify the channel number on which UART2 peripheral sends DMA request.
	//Channel 4
	pStream6->CR &= ~(0x7 << 25);
	pStream6->CR |=  (0x4 << 25);

	//4. Program the src address (Memory)
	pStream6->M0AR = (uint32_t) dataStream;

	//5. Program the dst address.(peripheral)
	pStream6->PAR = (uint32_t) &pUART2->DR;

	//6. Program the no. of data items to send.
	uint32_t len = sizeof(dataStream);
	pStream6->NDTR = len;

	//7. The direction of data transfer. M2P, P2M, M2M.
	pStream6->CR |= (0X1 << 6);

	//8. Program the src and dst data width.
	pStream6->CR &= ~(0x3 << 13);
	pStream6->CR &= ~(0x3 << 11);
	//8.1 Enable memory auto increment
	pStream6->CR |= (1 << 10);

	//9. Select Direct mode or FIFO mode.
	pStream6->FCR |=(1 << 2);

	//10. Select the FIFO threshold.
	pStream6->FCR &= ~(0x3 << 0);//clearing
	pStream6->FCR |=  (0x3 << 0);//setting

	//11. Enable the circular mode if required.

	//12. Single transfer or burst transfer.

	//13. Configure the stream priority.

	//14. Enable the stream.
//	pStream6->CR |= (1 << 0);
}

void enable_dma1_stream(void){
	DMA_Stream_TypeDef *pStream6;
	pStream6 = DMA1_Stream6;

	//Enable the stream
	pStream6->CR |= (1 << 0);
}

void dma1_interrupt_configuration(void){
	DMA_Stream_TypeDef *pStream6;
	pStream6 = DMA1_Stream6;

	//1. Do for Half-transfer IE (HTIE)
	pStream6->CR |= (1 << 3);

	//2. Transfer complete IE (TCIE)
	pStream6->CR |= (1 << 4);

	//3. Transfer error IE (TEIE)
	pStream6->CR |= (1 << 2);

	//4. FIFO overrun/underrun IE (FEIE)
	pStream6->FCR |= (1 << 7);

	//5. Direct mode error (DMIE)
	pStream6->CR |= (1 << 1);

	//6. Enable the  IRQ for DMA1 stream6 global interrupt in NVIC
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);
}
void HT_Complete_Callback(){

}
void FT_Complete_Callback(){

	DMA_Stream_TypeDef *pStream6;
	pStream6 = DMA1_Stream6;

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	uint32_t len = sizeof(dataStream);
	pStream6->NDTR = len;

	pUART2->CR3 &= ~(1 << 7);

	enable_dma1_stream();

}
void TE_Error_Callback(){
	while(1);
}
void FE_Error_Callback(){
	while(1);
}
void DME_Error_Callback(){
	while(1);
}
